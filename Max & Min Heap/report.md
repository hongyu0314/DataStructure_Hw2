# Max & Min Heap

## 解題說明

本題要求實現一個插入排

### 解題策略

1. Worst-case 的整數變數產生使用 n, n-1, n-2, ...... ,1。

2. Average-case 的整數變數產生使用隨機亂數(範圍設在0~9999)。

3. 測量排序時間使用 std::chrono。

## 程式實作

以下為Max Heap的程式碼：

```cpp


```
以下為Min Heap的程式碼：

```cpp

```
## 效能分析

1. 
    Worst-case:

     時間複雜度： $O(n²)$。
 
     空間複雜度： $O(1)$。
2. 
   Average-case：

     時間複雜度： $O(n²)$。
 
     空間複雜度： $O(1)$。

   **不需要額外的資料結構來存儲中間結果，它只是在原來的陣列上進行操作，因此空間複雜度是 $O(1)$。**


## 測試與驗證

### 測試案例

| 測試案例 | 參數個數 $n$ | Average-case所耗時間 | Worst-case所耗時間 |
|----------|--------------|----------|----------|
| 測試一   | $n = 500$      | 262 microseconds | 497 microseconds |
| 測試二   | $n = 1000$      | 696 microseconds | 1962 microseconds | 
| 測試三   | $n = 2000$      | 2721 microseconds | 9522 microseconds |
| 測試四   | $n = 3000$      | 7718 microseconds | 14336 microseconds |
| 測試五   | $n = 4000$      | 13504 microseconds | 29712 microseconds |
| 測試六   | $n = 5000$      | 22764 microseconds | 48361 microseconds |



## 申論及開發報告

### 在本程式中，使用插入排序法的主要原因如下：

1.  **簡單易懂**

      插入排序的邏輯簡單，容易實作和理解。


2. **處理小資料時效率較高**

     對於小型陣列，插入排序表現較好。時間複雜度在最好的情況是 $O(n)$ ，當陣列部分已經排序時，用插入排序時就會很快。

3. **穩定性**

     插入排序是一個穩定的排序方式，當有一樣的東西，排序後它們的順序不會改變。

### 插入排序法的缺點如下：

1. **不適合處理很多的資料**

     由於 $O(n²)$ 的時間複雜度，插入排序在處理很多資訊（例如數十萬或數百萬個資料）時效能會明顯下降，因此對大型資料的處理並不高效。

2. **交換次數多**

     在最壞情況下，插入排序需要大量的交換資料，尤其是在資料完全相反時的情況下。
